https://files.fm/u/bq7uhghhwp


```C
// Part 1

 * LAB3.c
 *
 * Created: 11/4/2025 2:36:34 PM
 * Author : lpizz
 */ 
/*
#include <stdio.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>	


int serial_receive(FILE *stream){
	// Wait until RXC flag is set to logic 1
	while ((UCSRA & (1 << RXC)) == 0x00){;}
	return UDR; // Read the received character from UDR
}

void serial_init(void){
	
	UCSRA = 0b00000000;			// Normal speed, disable multi-proc
	UCSRB = 0b00011000; 			// Enable Tx and Rx pins, enable RX interrupt
	UCSRC = 0b10000110;			// Asynchronous mode, no parity, 1 stop bit, 8 data bits
	UBRRL = 0x33; UBRRH = 0x00;	// Baud rate 1200bps, assuming 1MHz clock
}

int main(void){
DDRD = 0b00100000; // set port D for output (D.5 is OC1A)
// Set register TCCR1A
// WGM11:WGM10 = 10: with WGM13-WGM12 to select timer mode 1110
// Fast PWM, timer 1 runs from 0 to ICR1
// COM1A1:COM1A0 = 10: clear OC1A when compare match, set OC1A when 0
// compare match occurs when timer = OCR1A
TCCR1A = 0b10000010;
// Set register TCCR1B
// WGM13:WGM12 = 11
// CS12:CS0 = 001: internal clock 1MHz, no prescaler
TCCR1B = 0b00011001;
ICR1 = 4000;
OCR1A = 1000;
// period of output signal
// pulse width of output signal
while(1){;}
return 0;
}





// Part 2

#define F_CPU 1000000UL

#include <avr/io.h>
#include <stdint.h>


void uart_init(void)
{
    /* Baud = 1200, UBRR = F_CPU/(16*baud) - 1 = 51 */
    UBRRH = 0;
    UBRRL = 51;

    UCSRA = 0x00;                       // normal speed
    UCSRB = (1 << RXEN) | (1 << TXEN);  // enable RX, TX
    UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0); // 8 data, 1 stop, no parity
}

void uart_tx(char c)
{
    while (!(UCSRA & (1 << UDRE)));  // wait for buffer empty
    UDR = c;
}

char uart_rx(void)
{
    while (!(UCSRA & (1 << RXC)));   // wait for data
    return UDR;
}

void uart_print(const char *s)
{
    while (*s)
        uart_tx(*s++);
}

uint16_t uart_read_number(void)
{
    uint16_t value = 0;
    char c;

    while (1)
    {
        c = uart_rx();

        if (c == '\r' || c == '\n')   // Enter key
        {
            uart_print("\r\n");
            break;
        }

        if (c >= '0' && c <= '9')
        {
            uart_tx(c);               // echo
            value = value * 10 + (c - '0');
        }
    }
    return value;
}


void pwm_init(void)
{
    DDRD  |= (1 << PD5);  // OC1A output

    // Fast PWM, TOP = ICR1 (mode 14), non-inverting on OC1A, prescaler = 1
    TCCR1A = (1 << COM1A1) | (1 << WGM11);
    TCCR1B = (1 << WGM13)  | (1 << WGM12) | (1 << CS10);

    ICR1  = 4000;   // default: 250 Hz at 1 MHz clock
    OCR1A = 2000;   // default: 50% duty
}

void pwm_set(uint16_t freq_hz, uint8_t duty_percent)
{
    uint32_t top;

    if (freq_hz == 0)
        freq_hz = 1;          // avoid divide by zero
    if (duty_percent > 100)
        duty_percent = 100;

    // f_PWM = F_CPU / (1 * (1 + TOP))  ≈ F_CPU / (TOP + 1)
    top = (F_CPU / freq_hz) - 1;
    if (top > 65535)
        top = 65535;

    ICR1  = (uint16_t)top;
    OCR1A = (uint16_t)((top * duty_percent) / 100);
}


int main(void)
{
    uint16_t freq;
    uint8_t  duty;

    uart_init();
    pwm_init();

    uart_print("PWM generator ready.\r\n\r\n");

    while (1)
    {
        uart_print("Enter frequency in Hz: ");
        freq = uart_read_number();

        uart_print("Enter duty cycle (0-100%): ");
        duty = (uint8_t)uart_read_number();

        pwm_set(freq, duty);

        uart_print("PWM updated.\r\n\r\n");
    }
}









// Part 3

#include <avr/io.h>
#include <avr/interrupt.h>
#include <inttypes.h>
#include <stdio.h>
#include <util/delay.h>


// shared between ISR and main
volatile uint32_t period_us;          // 1 tick = 1 µs at 1 MHz, no prescale
volatile uint8_t  new_period_ready = 0;
volatile uint32_t frequency;


void serial_init(void){
	// Asynchronous, no parity, 1 stop, 8 data bits (URSEL=1)
	UCSRC = 0b10000110;
	UCSRA = 0x00;          // normal speed
	// 1200 bps @ 1 MHz -> 0x33
	UBRRL = 0x33;
	UBRRH = 0x00;
	// enable RX and TX, interrupts off
	UCSRB = 0b00011000;
}

void serial_send(unsigned char data){
	while ((UCSRA & (1 << UDRE)) == 0) {;}
	UDR = data;
}

unsigned char serial_receive(void){
	while ((UCSRA & (1 << RXC)) == 0) {;}
	return UDR;
}

int main(void) {
	DDRD = 0b00100000; // set port D for output (D.5 is OC1A)
	// Set register TCCR1A
	// WGM11:WGM10 = 10: with WGM13-WGM12 to select timer mode 1110
	// Fast PWM, timer 1 runs from 0 to ICR1
	// COM1A1:COM1A0 = 10: clear OC1A when compare match, set OC1A when 0
	// compare match occurs when timer = OCR1A
	
	TCCR1A = 0b10000010;
	// Set register TCCR1B
	// WGM13:WGM12 = 11
	// CS12:CS0 = 001: internal clock 1MHz, no prescaler
	
	TCCR1B = 0b00011001;
	//ICR1 = 1000; // period of output signal
	OCR1A = 250; // pulse width of output signal
	
	stdout = fdevopen(serial_send, NULL);
	stdin = fdevopen(NULL, serial_receive);
	serial_init();
	
	unsigned char a, b, c;
	int a_int, b_int;
	
	while(1) {
		ICR1 = 3030; // E4 (330 Hz)
		_delay_ms(250);

		ICR1 = 3210; // D#4 (311 Hz)
		_delay_ms(250);

		ICR1 = 3030; // E4 (330 Hz)
		_delay_ms(250);

		ICR1 = 3210; // D#4 (311 Hz)
		_delay_ms(250);

		ICR1 = 3030; // E4 (330 Hz)
		_delay_ms(250);

		ICR1 = 4050; // B3 (247 Hz)
		_delay_ms(250);

		ICR1 = 3400; // D4 (294 Hz)
		_delay_ms(250);

		ICR1 = 3820; // C4 (262 Hz)
		_delay_ms(250);

		ICR1 = 4550; // A3 (220 Hz)
		_delay_ms(500);

		ICR1 = 28;   // silence (36k Hz)
		_delay_ms(250);

		ICR1 = 7630; // C3 (131 Hz)
		_delay_ms(250);

		ICR1 = 6060; // E3 (165 Hz)
		_delay_ms(250);

		ICR1 = 4550; // A3 (220 Hz)
		_delay_ms(250);

		ICR1 = 4050; // B3 (247 Hz)
		_delay_ms(500);

		ICR1 = 28;   // silence (36k Hz)
		_delay_ms(250);

		ICR1 = 6060; // E3 (165 Hz)
		_delay_ms(250);

		ICR1 = 4810; // G#3 (208 Hz)
		_delay_ms(250);

		ICR1 = 4050; // B3 (247 Hz)
		_delay_ms(250);

		ICR1 = 3820; // C4 (262 Hz)
		_delay_ms(500);

	}
	
	
	
	
	
	
	return 0;
}

```
